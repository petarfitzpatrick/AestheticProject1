<!DOCTYPE html>
<html>
<head></head>

<body>

<canvas id="myCanvas" width="900" height="900">

</body>


<script>
(function(){
	
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");

    
c.addEventListener("mousedown", doMouseDown, false);

var c_x, c_y;
    
function doMouseDown(event){
	c_x = event.pageX;
	c_y = event.pageY;
	//console.log("X is " + c_x + " Y is " + c_y);
}

var grid = [];

//permaGrid to hold 7
var permaGrid = [];
    
var rowMax = 30;
var colMax = 30;

var soundGrid = [];

//Audio Stuff
var aud = new AudioContext();

var note = function( freq, attack, decay, delayTime ) {
  var osc = aud.createOscillator(),
      delay = aud.createDelay( 2 ),
      oscVolume  = aud.createGain(),
      feedback   = aud.createGain()
  
  osc.frequency.value = freq
  feedback.gain.value = .5
  delay.delayTime.value = delayTime // measured in ms
  
  // create volume envelope for oscillator
  oscVolume.gain.setValueAtTime( 0, aud.currentTime )
  oscVolume.gain.linearRampToValueAtTime( .04, aud.currentTime + attack )
  oscVolume.gain.linearRampToValueAtTime( 0, aud.currentTime + attack + decay )
  
  // connect oscillator to gain to control its volume
  osc.connect( oscVolume )

  // connect oscillator gain to output
  oscVolume.connect( aud.destination )
  
  // connect oscillator to delay
  oscVolume.connect( delay )

  // connect delay to feedback gain to control feedback amount
  delay.connect( feedback )

  // connect feedback control back into the delay to create loop
  feedback.connect( delay )

  // also connect delay to output
  delay.connect( aud.destination )

  // play a note immediately
  osc.start( aud.currentTime )

  // stop note after envelope is complete
  osc.stop( aud.currentTime + attack + decay )
}

//Create the grids
for (var row = 0; row < rowMax; row++){
	grid[row] = [];
    permaGrid[row] = [];
	soundGrid[row] = [];
}

//Begin program and loop it
init();
window.requestAnimationFrame(animate);

function animate() {
    setTimeout(function() {
      window.requestAnimationFrame(animate);
    }, 100);
		draw();
    update();
}

//Populates both two dimensional arrays
function init(){
	//Nested for loops to populate
	for(var row = 0; row < rowMax; row++){
		for(var col = 0; col < colMax; col++){
			//grid[row].push(Math.floor(Math.random() + 0.5));
			grid[row][col] = 0;
			soundGrid[row][col] = col*100;
        }
	}

}
    
function checkMouse(){
    //Account for margins
    var newX, newY;
    newX = c_x - 8;
    newY = c_y - 8;
    
    //New value to index col and row
    var colRef, rowRef;
    colRef = newX/30;
    rowRef = newY/30;
    
    if (newX > 0){
        //console.log("Nice " + colRef + "  " + rowRef);
        grid[Math.floor(colRef)][Math.floor(rowRef)] = 2;
    }
    
    c_x = 0;
    c_y = 0;
}

//Updates the grid every frame
function update(){
	//Clear to begin
	var newGrid = [];
	for (var row = 0; row < rowMax; row++){
		newGrid[row] = [];
	}
    
    //Holds values of next grid
    var nextGrid = [];
	for (var row = 0; row < rowMax; row++){
		nextGrid[row] = [];
	}
	
	for(var row = 0; row < rowMax; row++){
		for(var col = 0; col < colMax; col++){
			//Var to count neighbors
			var count = 0;
            
            if (row < 29){
                if (grid[row][col] == 2){
                     
                     //grid[row - 1][col] = 2;
                     //grid[row][col - 1] = 2;
                     nextGrid[row - 1][col] = 3;
                     nextGrid[row][col - 1] = 4;
                     nextGrid[row + 1][col] = 5;
                     nextGrid[row][col + 1] = 6;
                    
                     permaGrid[row][col] = 7;
                     nextGrid[row][col] = permaGrid[row][col];
                     note( soundGrid[row][col], .02, .04, .06 );

                //3 is the left movement value
                } else if (grid[row][col] == 3){
                    if (row > 0){
                     nextGrid[row - 1][col] = 3;
                    
                     nextGrid[row][col] = 1;
                    }
                //4 is the top movement value
                } else if (grid[row][col] == 4){
                     nextGrid[row][col - 1] = 4;
                    
                     nextGrid[row][col] = 1;
                //5 is the right movement value
                } else if (grid[row][col] == 5){
                     nextGrid[row + 1][col] = 5;
                    
                     nextGrid[row][col] = 1;
                //6 is the bottom movement value
                } else if (grid[row][col] == 6){
                     nextGrid[row][col + 1] = 6;
                    
                     nextGrid[row][col] = 1;
                }
            }
            
            
            
			//If there is an above row...
			if (row > 0){
				//Checking all values on row above
				
                
			}
			//If there is a bottom row...
			if (row < rowMax - 1){
				//Check all values on row below
				
			}
			//Check the left and right values
			
			
			//If it's alive
			
		}
	}
    
     for(var row = 0; row < rowMax; row++){
		   for(var col = 0; col < colMax; col++){
             if (grid[row][col] == 2){
                   //newGrid[row][col] = 2;
             } else if (grid[row][col] == 1){
                   //newGrid[row][col] = 1;
             } else if (grid[row][col] == 3){
                   //newGrid[row][col] = 3;
             } else {
                   //newGrid[row][col] = 0;
              }
            }
    }
	
	//Populate next grid
	for(var row = 0; row < rowMax; row++){
		for(var col = 0; col < colMax; col++){
			grid[row][col] = newGrid[row][col];
		}
	}
    
    for(var row = 0; row < rowMax; row++){
        for(var col = 0; col < colMax; col++){
            if (nextGrid[row][col]){
                grid[row][col] = nextGrid[row][col];
            } else {
                grid[row][col] = 0;
            }
        }
    }
    
    //Keep permaGrid values
    for(var row = 0; row < rowMax; row++){
        for(var col = 0; col < colMax; col++){
            if ((permaGrid[row][col] == 7 && grid[row][col] == 3) || (permaGrid[row][col] == 7 && grid[row][col] == 4) || (permaGrid[row][col] == 7 && grid[row][col] == 5) || (permaGrid[row][col] == 7 && grid[row][col] == 6)){
                console.log("Nice");
                grid[row][col] = permaGrid[row][col];
                
                grid[row - 1][col] = 3;
                grid[row][col - 1] = 4;
                grid[row + 1][col] = 5;
                grid[row][col + 1] = 6;
                
                note( soundGrid[row][col], .02, .04, .06 );
            }
            else if (permaGrid[row][col]){
                grid[row][col] = permaGrid[row][col];
            }
        }
    }
    
    
    checkMouse();
}


function draw(){
	//Nested for loop for actually drawing
	for(var rows = 0; rows < rowMax; rows++){
		for(var cols = 0; cols < colMax; cols++){
			if (grid[rows][cols] == 0 || grid[rows][cols] == 1){
				ctx.fillStyle = "#674172";
			} else if (grid[rows][cols] == 3 || grid[rows][cols] == 4 || grid[rows][cols] == 5 || grid[rows][cols] == 6){
				ctx.fillStyle = "#59ABE3";
			} else if (grid[rows][cols] == 2 || grid[rows][cols] == 7){
				ctx.fillStyle = "#FF0000";
			}
			//console.log(grid[rows][cols]);
			ctx.fillRect(rows * 30, cols * 30, 29, 29);
			
		}
	}
}

})();
</script>
</html>